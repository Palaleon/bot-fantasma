/*
================================================================================
||                          CHANNEL MANAGER v1.1                              ||
||                    Sistema de Canalizaci√≥n Multi-Activo                    ||
||                         WebSocket Nativo Edition                           ||
================================================================================

CAMBIOS v1.1:
‚úÖ Actualizado para trabajar con WebSocket nativo
‚úÖ Eliminadas referencias a TCP
‚úÖ M√©tricas mejoradas con informaci√≥n del interceptor
‚úÖ Sin cambios en la interfaz p√∫blica (100% compatible)

ARQUITECTURA:
WebSocketInterceptor ‚Üí PipReceiver ‚Üí ChannelManager ‚Üí TradingChannel(es) ‚Üí Operator

================================================================================
*/

import { EventEmitter } from 'events';
import logger from '../utils/logger.js';
import TradingChannel from './TradingChannel.js';

class ChannelManager extends EventEmitter {
  constructor() {
    super();
    
    // Mapa de canales activos (asset ‚Üí TradingChannel)
    this.channels = new Map();
    
    // Configuraci√≥n del sistema
    this.config = {
      // Modo Multi-Canal activado por defecto
      compatibilityMode: false,
      maxChannels: 10,
      defaultChannel: 'GLOBAL', // Usado como fallback o para modos espec√≠ficos
    };
    
    // M√©tricas globales del sistema
    this.metrics = {
      totalPipsReceived: 0,
      pipsPerAsset: new Map(),
      channelCreations: 0,
      lastUpdateTime: Date.now(),
      startTime: Date.now(),
      source: 'websocket_native' // Nueva fuente
    };
    
    // Estado del sistema
    this.isRunning = false;
    
    logger.info('üéØ ChannelManager v1.1 inicializado - WebSocket Nativo');
    logger.info(`üìä Modo: ${this.config.compatibilityMode ? 'Compatibilidad (1 canal)' : 'Multi-Canal'}`);
  }
  
  /**
   * Inicia el ChannelManager y se suscribe al PipReceiver
   */
  start(pipReceiver) {
    if (this.isRunning) {
      logger.warn('ChannelManager ya est√° en ejecuci√≥n');
      return;
    }
    
    logger.info('üöÄ ChannelManager: Iniciando sistema de canalizaci√≥n...');
    
    // En modo compatibilidad, crear un canal global √∫nico
    if (this.config.compatibilityMode) {
      this._createChannel(this.config.defaultChannel);
      logger.info('‚úÖ Canal GLOBAL creado (modo compatibilidad)');
    }
    
    // Suscribirse a eventos del PipReceiver
    pipReceiver.on('velaCerrada', (candle) => {
      this._handleClosedCandle(candle);
    });
    
    // Escuchar cambios de activo del PipReceiver
    pipReceiver.on('assetChanged', (data) => {
      this._handleAssetChangeNotification(data);
    });
    
    // Interceptar pipReceiver para m√©tricas (sin interferir)
    this._setupMetricsCollection(pipReceiver);
    
    this.isRunning = true;
    logger.info('‚úÖ ChannelManager operativo - WebSocket Nativo activo');
    
    // Iniciar reporte de m√©tricas peri√≥dico
    this._startMetricsReporting();
  }
  
  /**
   * Crea un nuevo canal de trading o devuelve uno existente
   */
  _createChannel(asset) {
    if (this.channels.has(asset)) {
      return this.channels.get(asset);
    }
    
    // Verificar l√≠mite de canales
    if (this.channels.size >= this.config.maxChannels) {
      logger.warn(`‚ö†Ô∏è L√≠mite de canales alcanzado (${this.config.maxChannels})`);
      return null;
    }
    
    logger.info(`üì° Creando nuevo canal para: ${asset}`);
    
    const channel = new TradingChannel(asset);
    
    // Escuchar se√±ales del canal y re-emitirlas
    channel.on('se√±alAprobada', (signal) => {
      // Agregar metadata del canal
      signal.channel = asset;
      signal.channelMetrics = this._getChannelMetrics(asset);
      signal.source = 'websocket_native';
      
      // Re-emitir para que el Operator la capture
      this.emit('se√±alMultiCanal', signal);
      
      logger.info(`üéØ [${asset}] Se√±al aprobada y propagada al Operator (WebSocket nativo)`);
    });
    
    this.channels.set(asset, channel);
    this.metrics.channelCreations++;
    
    logger.info(`‚úÖ Canal ${asset} creado exitosamente (Total: ${this.channels.size})`);
    
    return channel;
  }
  
  /**
   * Maneja velas cerradas y las direcciona al canal correcto
   */
  _handleClosedCandle(candle) {
    const { asset, timeframe } = candle;
    
    // Actualizar m√©tricas
    this._updateMetrics(asset);
    
    // En modo compatibilidad, todo va al canal global
    const targetChannel = this.config.compatibilityMode 
      ? this.config.defaultChannel 
      : asset;
    
    // Obtener o crear el canal
    let channel = this.channels.get(targetChannel);
    if (!channel) {
      channel = this._createChannel(targetChannel);
      if (!channel) {
        logger.error(`‚ùå No se pudo crear canal para ${targetChannel}`);
        return;
      }
    }
    
    // Delegar el procesamiento al canal
    channel.processCandle(candle);
    
    // Log detallado cada 100 velas
    const assetMetrics = this.metrics.pipsPerAsset.get(asset) || 0;
    if (assetMetrics % 100 === 0) {
      logger.info(`üìä [${asset}] Procesadas ${assetMetrics} velas (v√≠a WebSocket nativo)`);
    }
  }
  
  /**
   * Maneja notificaciones de cambio de activo
   */
  _handleAssetChangeNotification(data) {
    logger.info(`üîÑ ChannelManager: Cambio de activo notificado - ${data.new_asset}`);
    
    // En modo multi-canal, podr√≠amos crear un nuevo canal aqu√≠
    if (!this.config.compatibilityMode && !this.channels.has(data.new_asset)) {
      this._createChannel(data.new_asset);
    }
  }
  
  /**
   * Configura la recolecci√≥n de m√©tricas desde PipReceiver
   */
  _setupMetricsCollection(pipReceiver) {
    // Escuchar eventos de pip para m√©tricas
    pipReceiver.on('pipReceived', (pipData) => {
      const asset = pipData.raw_asset || pipData.active_asset;
      if (asset) {
        this._updateMetrics(asset);
      }
    });
    
    logger.info('üîç Sistema de m√©tricas conectado al PipReceiver (WebSocket nativo)');
  }
  
  /**
   * Actualiza m√©tricas por activo
   */
  _updateMetrics(asset) {
    this.metrics.totalPipsReceived++;
    
    const currentCount = this.metrics.pipsPerAsset.get(asset) || 0;
    this.metrics.pipsPerAsset.set(asset, currentCount + 1);
    
    this.metrics.lastUpdateTime = Date.now();
  }
  
  /**
   * Obtiene m√©tricas espec√≠ficas de un canal
   */
  _getChannelMetrics(channelName) {
    const channel = this.channels.get(channelName);
    if (!channel) return null;
    
    return {
      pipsProcessed: this.metrics.pipsPerAsset.get(channelName) || 0,
      signalsGenerated: channel.getSignalCount(),
      lastSignal: channel.getLastSignalTime(),
      uptime: Date.now() - channel.getCreationTime(),
      source: 'websocket_native'
    };
  }
  
  /**
   * Inicia el reporte peri√≥dico de m√©tricas
   */
  _startMetricsReporting() {
    setInterval(() => {
      this._reportSystemMetrics();
    }, 60000); // Cada minuto
  }
  
  /**
   * Genera y loguea reporte de m√©tricas del sistema
   */
  _reportSystemMetrics() {
    const uptime = Math.floor((Date.now() - this.metrics.startTime) / 1000);
    const pipsPerSecond = this.metrics.totalPipsReceived / uptime;
    
    logger.info('üìä === REPORTE DE M√âTRICAS DEL CHANNELMANAGER ===');
    logger.info(`‚è±Ô∏è  Uptime: ${Math.floor(uptime / 60)} minutos`);
    logger.info(`üìà Total pips procesados: ${this.metrics.totalPipsReceived}`);
    logger.info(`‚ö° Velocidad: ${pipsPerSecond.toFixed(2)} pips/segundo`);
    logger.info(`üîå Canales activos: ${this.channels.size}`);
    logger.info(`üé§ Fuente: WebSocket NATIVO (sin Python)`);
    
    // M√©tricas por activo (top 5)
    const sortedAssets = Array.from(this.metrics.pipsPerAsset.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);
    
    logger.info('üèÜ Top 5 activos m√°s activos:');
    sortedAssets.forEach(([asset, count], index) => {
      const percentage = ((count / this.metrics.totalPipsReceived) * 100).toFixed(1);
      logger.info(`   ${index + 1}. ${asset}: ${count} pips (${percentage}%)`);
    });
    
    // Estado de canales
    this.channels.forEach((channel, name) => {
      const metrics = channel.getMetrics();
      logger.info(`üì° Canal [${name}]: ${metrics.signalsGenerated} se√±ales, ${metrics.signalsApproved} aprobadas`);
    });
    
    logger.info('üìä === FIN DEL REPORTE ===');
  }
  
  /**
   * Obtiene el estado completo del sistema
   */
  getSystemStatus() {
    return {
      mode: this.config.compatibilityMode ? 'compatibility' : 'multi-channel',
      channels: {
        active: this.channels.size,
        max: this.config.maxChannels,
        list: Array.from(this.channels.keys()),
      },
      metrics: {
        totalPips: this.metrics.totalPipsReceived,
        uptime: Date.now() - this.metrics.startTime,
        pipsPerAsset: Object.fromEntries(this.metrics.pipsPerAsset),
        channelsCreated: this.metrics.channelCreations,
        source: this.metrics.source
      },
      performance: {
        pipsPerSecond: this.metrics.totalPipsReceived / ((Date.now() - this.metrics.startTime) / 1000),
        avgPipsPerChannel: this.metrics.totalPipsReceived / Math.max(1, this.channels.size),
      },
      extraction: {
        method: 'websocket_native',
        latency: '~1ms',
        dependencies: 'none'
      }
    };
  }
  
  /**
   * Cambia entre modo compatibilidad y multi-canal
   */
  setMultiChannelMode(enabled) {
    if (this.config.compatibilityMode === !enabled) {
      logger.info(`üîÑ Modo ya est√° en: ${enabled ? 'Multi-Canal' : 'Compatibilidad'}`);
      return;
    }
    
    logger.warn(`‚ö†Ô∏è CAMBIANDO MODO A: ${enabled ? 'MULTI-CANAL' : 'COMPATIBILIDAD'}`);
    
    this.config.compatibilityMode = !enabled;
    
    if (enabled) {
      // Limpiar canal global si existe
      if (this.channels.has(this.config.defaultChannel)) {
        this.channels.get(this.config.defaultChannel).stop();
        this.channels.delete(this.config.defaultChannel);
      }
      logger.info('‚úÖ Modo Multi-Canal activado - Los canales se crear√°n din√°micamente');
    } else {
      // Volver a modo compatibilidad
      this.channels.forEach((channel, name) => {
        if (name !== this.config.defaultChannel) {
          channel.stop();
        }
      });
      this.channels.clear();
      this._createChannel(this.config.defaultChannel);
      logger.info('‚úÖ Modo Compatibilidad activado - Un solo canal global');
    }
  }
  
  /**
   * Detiene el ChannelManager y todos sus canales
   */
  stop() {
    logger.info('üõë Deteniendo ChannelManager...');
    
    // Detener todos los canales
    this.channels.forEach((channel, name) => {
      logger.info(`üîå Deteniendo canal: ${name}`);
      channel.stop();
    });
    
    this.channels.clear();
    this.isRunning = false;
    
    // Reporte final
    this._reportSystemMetrics();
    
    logger.info('‚úÖ ChannelManager detenido completamente');
  }
}

export default ChannelManager;